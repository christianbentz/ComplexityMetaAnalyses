value.nt <- c(value.m, value.s.nt)
value.nt
value.s.nt.scaled <- scale(value.s.nt)
value.nt.scaled <- c(value.m.scaled, value.s.nt.scaled)
value.nt.scaled
knitr::opts_chunk$set(echo = TRUE)
set.seed(1)
# set parameters
n = 5 # number of languages
k = 10 # number of measures in domain
r = -0.8 # predefined correlation between the complexity values in the two domains
# generate the data
simulation.df <- data.frame()
for (i in 1:k){
# generate two correlated samples
data <- mvrnorm(n = n, mu = c(3, 3), Sigma = matrix(c(1, r, r, 1), nrow = 2),
empirical = TRUE)
# original values
value.m <- data[, 1]
value.s <- data[, 2]
value <- c(value.m, value.s)
# scaled original values
value.m.scaled <- scale(value.m)
value.s.scaled <- scale(value.s)
value.scaled <- c(value.m.scaled, value.s.scaled)
# add information about domain and measurement id
domain <- c(rep("morphology", n), rep("syntax", n))
measure <- rep(i, n)
# create vector with language names
language <- c()
for (j in 1:n){
language <- c(language, paste("language", j))
}
local.df <- cbind(language, measure, domain, value, value.scaled)
simulation.df <- rbind(simulation.df, local.df)
}
library(MASS)
library(ggplot2)
library(plyr)
library(dplyr)
library(GGally)
library(rstatix)
set.seed(1)
# set parameters
n = 5 # number of languages
k = 10 # number of measures in domain
r = -0.8 # predefined correlation between the complexity values in the two domains
# generate the data
simulation.df <- data.frame()
for (i in 1:k){
# generate two correlated samples
data <- mvrnorm(n = n, mu = c(3, 3), Sigma = matrix(c(1, r, r, 1), nrow = 2),
empirical = TRUE)
# original values
value.m <- data[, 1]
value.s <- data[, 2]
value <- c(value.m, value.s)
# scaled original values
value.m.scaled <- scale(value.m)
value.s.scaled <- scale(value.s)
value.scaled <- c(value.m.scaled, value.s.scaled)
# add information about domain and measurement id
domain <- c(rep("morphology", n), rep("syntax", n))
measure <- rep(i, n)
# create vector with language names
language <- c()
for (j in 1:n){
language <- c(language, paste("language", j))
}
local.df <- cbind(language, measure, domain, value, value.scaled)
simulation.df <- rbind(simulation.df, local.df)
}
# set value columns back to numeric
simulation.df$value <- as.numeric(as.character(simulation.df$value))
simulation.df$value.scaled <- as.numeric(as.character(simulation.df$value.scaled))
simulation.df
set.seed(1)
# set parameters
n = 5 # number of languages
k = 10 # number of measures in domain
r = -0.8 # predefined correlation between the complexity values in the two domains
# generate the data
simulation.df <- data.frame()
for (i in 1:k){
# generate two correlated samples
data <- mvrnorm(n = n, mu = c(3, 3), Sigma = matrix(c(1, r, r, 1), nrow = 2),
empirical = TRUE)
# original values
value.m <- data[, 1]
value.s <- data[, 2]
value <- c(value.m, value.s)
# scaled original values
value.m.scaled <- scale(value.m)
value.s.scaled <- scale(value.s)
value.scaled <- c(value.m.scaled, value.s.scaled)
# add information about domain and measurement id
domain <- c(rep("morphology", n), rep("syntax", n))
measure <- rep(i, n)
# create vector with language names
language <- c()
for (j in 1:n){
language <- c(language, paste("language", j))
}
local.df <- cbind(language, measure, domain, value, value.scaled)
simulation.df <- rbind(simulation.df, local.df)
}
# set value columns back to numeric
simulation.df$value <- as.numeric(as.character(simulation.df$value))
simulation.df$value.scaled <- as.numeric(as.character(simulation.df$value.scaled))
simulation.df
simulation.df$value[simulation.df$language == "language 1"] <- 0
head(simulation.df)
simulation.df$value[simulation.df$language == "language 1" & simulation.df$domain == "syntax"] <- 0
simulation.df$value[simulation.df$language == "language 1" & simulation.df$domain == "syntax"] <- 2
View(simulation.df)
simulation.df$value[simulation.df$language == "language 1" & simulation.df$domain == "syntax"]
set.seed(1)
# set parameters
n = 5 # number of languages
k = 10 # number of measures in domain
r = -0.8 # predefined correlation between the complexity values in the two domains
# generate the data
simulation.df <- data.frame()
for (i in 1:k){
# generate two correlated samples
data <- mvrnorm(n = n, mu = c(3, 3), Sigma = matrix(c(1, r, r, 1), nrow = 2),
empirical = TRUE)
# original values
value.m <- data[, 1]
value.s <- data[, 2]
value <- c(value.m, value.s)
# scaled original values
value.m.scaled <- scale(value.m)
value.s.scaled <- scale(value.s)
value.scaled <- c(value.m.scaled, value.s.scaled)
# add information about domain and measurement id
domain <- c(rep("morphology", n), rep("syntax", n))
measure <- rep(i, n)
# create vector with language names
language <- c()
for (j in 1:n){
language <- c(language, paste("language", j))
}
local.df <- cbind(language, measure, domain, value, value.scaled)
simulation.df <- rbind(simulation.df, local.df)
}
# set value columns back to numeric
simulation.df$value <- as.numeric(as.character(simulation.df$value))
simulation.df$value.scaled <- as.numeric(as.character(simulation.df$value.scaled))
simulation.df$value[simulation.df$language == "language 1" & simulation.df$domain == "syntax"] <- simulation.df$value[simulation.df$language == "language 1" & simulation.df$domain == "syntax"]*0.5
View(simulation.df)
View(simulation.df)
mu <- ddply(simulation.df, "language", summarise, grp.mean = mean(value, na.rm = T))
# get median values for each language
med <- ddply(simulation.df, "language", summarise, grp.median = median(value, na.rm = T))
# get standard deviation values for each language
sdev <- ddply(simulation.df, "language", summarise, grp.sd = sd(value, na.rm = T))
density.plot <- ggplot(simulation.df, aes(x = value, color = domain, fill = domain)) +
geom_density(alpha = .2) +
geom_jitter(data = simulation.df, aes(x = value, y = 0),
size = 1, height = 0.001, width = 0) + # add some jitter to prevent overplotting
geom_vline(aes(xintercept = 0), color = "darkgrey") +
geom_vline(data = med, aes(xintercept = grp.median), linetype = "dashed") +
facet_wrap(~ language) +
#xlim(-3, 3) +
labs(x = "Complexity Value", y = "Density") +
theme_bw()
print(density.plot)
simulation.df$value.nt <- simulation.df$value[simulation.df$language == "language 1" & simulation.df$domain == "syntax"] <- simulation.df$value[simulation.df$language == "language 1" & simulation.df$domain == "syntax"]*0.5
View(simulation.df)
set.seed(1)
# set parameters
n = 5 # number of languages
k = 10 # number of measures in domain
r = -0.8 # predefined correlation between the complexity values in the two domains
# generate the data
simulation.df <- data.frame()
for (i in 1:k){
# generate two correlated samples
data <- mvrnorm(n = n, mu = c(3, 3), Sigma = matrix(c(1, r, r, 1), nrow = 2),
empirical = TRUE)
# original values
value.m <- data[, 1]
value.s <- data[, 2]
value <- c(value.m, value.s)
# scaled original values
value.m.scaled <- scale(value.m)
value.s.scaled <- scale(value.s)
value.scaled <- c(value.m.scaled, value.s.scaled)
# add information about domain and measurement id
domain <- c(rep("morphology", n), rep("syntax", n))
measure <- rep(i, n)
# create vector with language names
language <- c()
for (j in 1:n){
language <- c(language, paste("language", j))
}
local.df <- cbind(language, measure, domain, value, value.scaled)
simulation.df <- rbind(simulation.df, local.df)
}
# set value columns back to numeric
simulation.df$value <- as.numeric(as.character(simulation.df$value))
simulation.df$value.scaled <- as.numeric(as.character(simulation.df$value.scaled))
simulation.df$value.nt <- simulation.df$value[simulation.df$language == "language 1" & simulation.df$domain == "syntax"] <- simulation.df$value[simulation.df$language == "language 1" & simulation.df$domain == "syntax"]*0.5
View(simulation.df)
set.seed(1)
# set parameters
n = 5 # number of languages
k = 10 # number of measures in domain
r = -0.8 # predefined correlation between the complexity values in the two domains
# generate the data
simulation.df <- data.frame()
for (i in 1:k){
# generate two correlated samples
data <- mvrnorm(n = n, mu = c(3, 3), Sigma = matrix(c(1, r, r, 1), nrow = 2),
empirical = TRUE)
# original values
value.m <- data[, 1]
value.s <- data[, 2]
value <- c(value.m, value.s)
# scaled original values
value.m.scaled <- scale(value.m)
value.s.scaled <- scale(value.s)
value.scaled <- c(value.m.scaled, value.s.scaled)
# add information about domain and measurement id
domain <- c(rep("morphology", n), rep("syntax", n))
measure <- rep(i, n)
# create vector with language names
language <- c()
for (j in 1:n){
language <- c(language, paste("language", j))
}
local.df <- cbind(language, measure, domain, value, value.scaled)
simulation.df <- rbind(simulation.df, local.df)
}
# set value columns back to numeric
simulation.df$value <- as.numeric(as.character(simulation.df$value))
simulation.df$value.scaled <- as.numeric(as.character(simulation.df$value.scaled))
simulation.df
simulation.df$value.nt <- simulation.df$value
simulation.df
simulation.df$value.nt[simulation.df$language == "language 1" & simulation.df$domain == "syntax"] <- simulation.df$value.nt[simulation.df$language == "language 1" & simulation.df$domain == "syntax"]*0.5
View(simulation.df)
i
data <- mvrnorm(n = n, mu = c(3, 3), Sigma = matrix(c(1, r, r, 1), nrow = 2),
empirical = TRUE)
# original values
value.m <- data[, 1]
value.s <- data[, 2]
value <- c(value.m, value.s)
# scaled original values
value.m.scaled <- scale(value.m)
value.s.scaled <- scale(value.s)
value.scaled <- c(value.m.scaled, value.s.scaled)
# add information about domain and measurement id
domain <- c(rep("morphology", n), rep("syntax", n))
measure <- rep(i, n)
# create vector with language names
language <- c()
for (j in 1:n){
language <- c(language, paste("language", j))
}
local.df <- cbind(language, measure, domain, value, value.scaled)
# linear transformation to syntax of language 1
local.df$value.lt <- local.df$value
local.df
local.df$value.lt <- local.df$value
set.seed(1)
# set parameters
n = 5 # number of languages
k = 10 # number of measures in domain
r = -0.8 # predefined correlation between the complexity values in the two domains
# generate the data
simulation.df <- data.frame()
for (i in 1:k){
# generate two correlated samples
data <- mvrnorm(n = n, mu = c(3, 3), Sigma = matrix(c(1, r, r, 1), nrow = 2),
empirical = TRUE)
# original values
value.m <- data[, 1]
value.s <- data[, 2]
value <- c(value.m, value.s)
# scaled original values
value.m.scaled <- scale(value.m)
value.s.scaled <- scale(value.s)
value.scaled <- c(value.m.scaled, value.s.scaled)
# add information about domain and measurement id
domain <- c(rep("morphology", n), rep("syntax", n))
measure <- rep(i, n)
# create vector with language names
language <- c()
for (j in 1:n){
language <- c(language, paste("language", j))
}
local.df <- cbind(language, measure, domain, value, value.scaled)
# linear transformation to syntax of language 1
local.df$value.lt <- local.df$value
local.df$value.lt[local.df$language == "language 1" & local.df$domain == "syntax"] <-
local.df$value.lt[local.df$language == "language 1" & local.df$domain == "syntax"]*0.5
#local.df$value.lt.scaled <- c(scale(local.df$value))
# non-linear transformation to syntax of language 2
local.df$value.nt <- local.df$value
local.df$value.nt[local.df$language == "language 2" & local.df$domain == "syntax"] <-
local.df$value.nt[local.df$language == "language 2" & local.df$domain == "syntax"]^2
# bind to overall data frame
simulation.df <- rbind(simulation.df, local.df)
}
data <- mvrnorm(n = n, mu = c(3, 3), Sigma = matrix(c(1, r, r, 1), nrow = 2),
empirical = TRUE)
# original values
value.m <- data[, 1]
value.s <- data[, 2]
value <- c(value.m, value.s)
# scaled original values
value.m.scaled <- scale(value.m)
value.s.scaled <- scale(value.s)
value.scaled <- c(value.m.scaled, value.s.scaled)
# add information about domain and measurement id
domain <- c(rep("morphology", n), rep("syntax", n))
measure <- rep(i, n)
# create vector with language names
language <- c()
for (j in 1:n){
language <- c(language, paste("language", j))
}
value.scaled
domain
measures
measure
i
language
local.df <- cbind(language, measure, domain, value, value.scaled)
local.df
local.df$value
local.df$language
local.df <- data.frame(language, measure, domain, value, value.scaled)
local.df
local.df$value.lt <- local.df$value
local.df$value.lt[local.df$language == "language 1" & local.df$domain == "syntax"] <-
local.df$value.lt[local.df$language == "language 1" & local.df$domain == "syntax"]*0.5
local.df$value.nt <- local.df$value
local.df$value.nt[local.df$language == "language 2" & local.df$domain == "syntax"] <-
local.df$value.nt[local.df$language == "language 2" & local.df$domain == "syntax"]^2
# bind to overall data frame
simulation.df <- rbind(simulation.df, local.df)
simulation.df
set.seed(1)
# set parameters
n = 5 # number of languages
k = 10 # number of measures in domain
r = -0.8 # predefined correlation between the complexity values in the two domains
# generate the data
simulation.df <- data.frame()
for (i in 1:k){
# generate two correlated samples
data <- mvrnorm(n = n, mu = c(3, 3), Sigma = matrix(c(1, r, r, 1), nrow = 2),
empirical = TRUE)
# original values
value.m <- data[, 1]
value.s <- data[, 2]
value <- c(value.m, value.s)
# scaled original values
value.m.scaled <- scale(value.m)
value.s.scaled <- scale(value.s)
value.scaled <- c(value.m.scaled, value.s.scaled)
# add information about domain and measurement id
domain <- c(rep("morphology", n), rep("syntax", n))
measure <- rep(i, n)
# create vector with language names
language <- c()
for (j in 1:n){
language <- c(language, paste("language", j))
}
local.df <- data.frame(language, measure, domain, value, value.scaled)
# linear transformation to syntax of language 1
local.df$value.lt <- local.df$value
local.df$value.lt[local.df$language == "language 1" & local.df$domain == "syntax"] <-
local.df$value.lt[local.df$language == "language 1" & local.df$domain == "syntax"]*0.5
#local.df$value.lt.scaled <- c(scale(local.df$value))
# non-linear transformation to syntax of language 2
local.df$value.nt <- local.df$value
local.df$value.nt[local.df$language == "language 2" & local.df$domain == "syntax"] <-
local.df$value.nt[local.df$language == "language 2" & local.df$domain == "syntax"]^2
# bind to overall data frame
simulation.df <- rbind(simulation.df, local.df)
}
mu <- ddply(simulation.df, "language", summarise, grp.mean = mean(value, na.rm = T))
# get median values for each language
med <- ddply(simulation.df, "language", summarise, grp.median = median(value, na.rm = T))
# get standard deviation values for each language
sdev <- ddply(simulation.df, "language", summarise, grp.sd = sd(value, na.rm = T))
density.plot <- ggplot(simulation.df, aes(x = value, color = domain, fill = domain)) +
geom_density(alpha = .2) +
geom_jitter(data = simulation.df, aes(x = value, y = 0),
size = 1, height = 0.001, width = 0) + # add some jitter to prevent overplotting
geom_vline(aes(xintercept = 0), color = "darkgrey") +
geom_vline(data = med, aes(xintercept = grp.median), linetype = "dashed") +
facet_wrap(~ language) +
#xlim(-3, 3) +
labs(x = "Complexity Value", y = "Density") +
theme_bw()
print(density.plot)
View(simulation.df)
mu <- ddply(simulation.df, "language", summarise, grp.mean = mean(value.nt, na.rm = T))
# get median values for each language
med <- ddply(simulation.df, "language", summarise, grp.median = median(value.nt, na.rm = T))
# get standard deviation values for each language
sdev <- ddply(simulation.df, "language", summarise, grp.sd = sd(value.nt, na.rm = T))
density.plot <- ggplot(simulation.df, aes(x = value.nt, color = domain, fill = domain)) +
geom_density(alpha = .2) +
geom_jitter(data = simulation.df, aes(x = value.nt, y = 0),
size = 1, height = 0.001, width = 0) + # add some jitter to prevent overplotting
geom_vline(aes(xintercept = 0), color = "darkgrey") +
geom_vline(data = med, aes(xintercept = grp.median), linetype = "dashed") +
facet_wrap(~ language) +
#xlim(-3, 3) +
labs(x = "Complexity Value", y = "Density") +
theme_bw()
print(density.plot)
set.seed(1)
# set parameters
n = 5 # number of languages
k = 10 # number of measures in domain
r = -0.8 # predefined correlation between the complexity values in the two domains
# generate the data
simulation.df <- data.frame()
for (i in 1:k){
# generate two correlated samples
data <- mvrnorm(n = n, mu = c(3, 3), Sigma = matrix(c(1, r, r, 1), nrow = 2),
empirical = TRUE)
# original values
value.m <- data[, 1]
value.s <- data[, 2]
value <- c(value.m, value.s)
# scaled original values
value.m.scaled <- scale(value.m)
value.s.scaled <- scale(value.s)
value.scaled <- c(value.m.scaled, value.s.scaled)
# add information about domain and measurement id
domain <- c(rep("morphology", n), rep("syntax", n))
measure <- rep(i, n)
# create vector with language names
language <- c()
for (j in 1:n){
language <- c(language, paste("language", j))
}
local.df <- data.frame(language, measure, domain, value, value.scaled)
# linear transformation to syntax of language 1
local.df$value.lt <- local.df$value
local.df$value.lt[local.df$language == "language 1" & local.df$domain == "syntax"] <-
local.df$value.lt[local.df$language == "language 1" & local.df$domain == "syntax"]*0.5
local.df$value.lt.scaled <- c(value.m.scaled, scale(local.df.value.lt[local.df$domain == "syntax"]))
# non-linear transformation to syntax of language 2
local.df$value.nt <- local.df$value
local.df$value.nt[local.df$language == "language 2" & local.df$domain == "syntax"] <-
local.df$value.nt[local.df$language == "language 2" & local.df$domain == "syntax"]^2
local.df$value.nt.scaled <- c(value.m.scaled, scale(local.df.value.nt[local.df$domain == "syntax"]))
# bind to overall data frame
simulation.df <- rbind(simulation.df, local.df)
}
set.seed(1)
# set parameters
n = 5 # number of languages
k = 10 # number of measures in domain
r = -0.8 # predefined correlation between the complexity values in the two domains
# generate the data
simulation.df <- data.frame()
for (i in 1:k){
# generate two correlated samples
data <- mvrnorm(n = n, mu = c(3, 3), Sigma = matrix(c(1, r, r, 1), nrow = 2),
empirical = TRUE)
# original values
value.m <- data[, 1]
value.s <- data[, 2]
value <- c(value.m, value.s)
# scaled original values
value.m.scaled <- scale(value.m)
value.s.scaled <- scale(value.s)
value.scaled <- c(value.m.scaled, value.s.scaled)
# add information about domain and measurement id
domain <- c(rep("morphology", n), rep("syntax", n))
measure <- rep(i, n)
# create vector with language names
language <- c()
for (j in 1:n){
language <- c(language, paste("language", j))
}
local.df <- data.frame(language, measure, domain, value, value.scaled)
# linear transformation to syntax of language 1
local.df$value.lt <- local.df$value
local.df$value.lt[local.df$language == "language 1" & local.df$domain == "syntax"] <-
local.df$value.lt[local.df$language == "language 1" & local.df$domain == "syntax"]*0.5
local.df$value.lt.scaled <- c(value.m.scaled, scale(local.df$value.lt[local.df$domain == "syntax"]))
# non-linear transformation to syntax of language 2
local.df$value.nt <- local.df$value
local.df$value.nt[local.df$language == "language 2" & local.df$domain == "syntax"] <-
local.df$value.nt[local.df$language == "language 2" & local.df$domain == "syntax"]^2
local.df$value.nt.scaled <- c(value.m.scaled, scale(local.df$value.nt[local.df$domain == "syntax"]))
# bind to overall data frame
simulation.df <- rbind(simulation.df, local.df)
}
View(simulation.df)
simulation.df.wide <- reshape(simulation.df, idvar = c("language", "measure"), timevar = "domain", direction = "wide")
# select only certain columns for plotting
simulation.df.short <- select(simulation.df.wide, value.morphology, value.scaled.morphology, value.nt.syntax, value.scaled.syntax, value.lt.scaled.syntax, value.nt.scaled.syntax)
simulation.scatterplot <- ggpairs(simulation.df.short,
lower = list(continuous = wrap("smooth_loess", alpha = 0.3,
lwd = 0.5, size = 2))) +
#upper = list(continuous = wrap('cor', method = "spearman"))) +
theme_bw() +
theme(axis.text.x = element_text(angle = 90, hjust = 1))
print(simulation.scatterplot)
